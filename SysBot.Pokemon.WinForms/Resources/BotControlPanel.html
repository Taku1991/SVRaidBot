<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, maximum-scale=5.0">
    <title>Universal Bot Control Center</title>
    <style>
        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #151932;
            --bg-card: #1e2139;
            --bg-hover: #252846;
            --text-primary: #ffffff;
            --text-secondary: #a8aec0;
            --accent: #7c3aed;
            --accent-hover: #6d28d9;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: #2d3054;
            --online: #10b981;
            --offline: #6b7280;
            --idle: #f59e0b;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            --shadow-hover: 0 8px 24px rgba(0, 0, 0, 0.4);
            --border-radius: 12px;
            --border-radius-sm: 8px;
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            font-size: clamp(14px, 2.5vw, 16px);
        }

        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(21, 25, 50, 0.95);
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            min-width: 0;
        }

            .logo h1 {
                font-size: clamp(1.25rem, 4vw, 1.5rem);
                font-weight: 700;
                color: var(--accent);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
            flex-shrink: 0;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(16, 185, 129, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
            }
        }

        .refresh-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .refresh-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            transition: all 0.3s ease;
            cursor: help;
        }

            .refresh-indicator.paused {
                background: var(--warning);
                animation: pulse-warning 2s infinite;
            }

            .refresh-indicator:hover {
                transform: scale(1.5);
            }

        @keyframes pulse-warning {
            0% {
                box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7);
            }

            70% {
                box-shadow: 0 0 0 8px rgba(245, 158, 11, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(245, 158, 11, 0);
            }
        }

        .main {
            flex: 1;
            padding: var(--spacing-lg);
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .global-controls {
            background: var(--bg-card);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            border: 1px solid var(--border);
        }

            .global-controls h2 {
                font-size: clamp(1rem, 3vw, 1.2rem);
                margin-bottom: var(--spacing-md);
                color: var(--text-secondary);
            }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: var(--spacing-sm);
        }

        .btn {
            padding: var(--spacing-sm) var(--spacing-md);
            border: none;
            border-radius: var(--border-radius-sm);
            font-size: clamp(0.75rem, 2.5vw, 0.875rem);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            background: var(--bg-hover);
            color: var(--text-primary);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            min-height: 44px;
            white-space: nowrap;
            text-decoration: none;
        }

            .btn:hover:not(:disabled) {
                transform: translateY(-2px);
                box-shadow: var(--shadow);
            }

            .btn:active {
                transform: translateY(0);
            }

            .btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none !important;
            }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
        }

            .btn-primary:hover:not(:disabled) {
                background: var(--accent-hover);
            }

        .btn-success {
            background: var(--success);
            border-color: var(--success);
        }

        .btn-warning {
            background: var(--warning);
            border-color: var(--warning);
            color: #000;
        }

        .btn-danger {
            background: var(--danger);
            border-color: var(--danger);
        }

        .btn-raidbot {
            background: linear-gradient(135deg, #8b5cf6, #a855f7);
            border-color: #8b5cf6;
            color: white;
        }

            .btn-raidbot:hover:not(:disabled) {
                background: linear-gradient(135deg, #7c3aed, #9333ea);
        }

        .scheduled-restart-section {
            background: var(--bg-card);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            border: 1px solid var(--border);
        }

        .scheduled-restart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

            .scheduled-restart-header h2 {
                font-size: clamp(1rem, 3vw, 1.2rem);
                color: var(--text-secondary);
            }

        .restart-schedule-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .schedule-toggle {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
            cursor: pointer;
        }

            .toggle-switch input {
                display: none;
            }

        .toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 24px;
            transition: all 0.3s ease;
        }

            .toggle-slider::before {
                content: '';
                position: absolute;
                width: 16px;
                height: 16px;
                left: 4px;
                bottom: 3px;
                background: var(--text-secondary);
                border-radius: 50%;
                transition: all 0.3s ease;
            }

        .toggle-switch input:checked + .toggle-slider {
            background: var(--accent);
            border-color: var(--accent);
        }

            .toggle-switch input:checked + .toggle-slider::before {
                transform: translateX(24px);
                background: white;
            }

        .time-input-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .time-input {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            color: var(--text-primary);
            font-size: 12px;
            font-family: monospace;
            width: 100px;
            transition: all 0.2s ease;
        }

            .time-input:focus {
                outline: none;
                border-color: var(--accent);
                box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.2);
            }

            .time-input:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

        .schedule-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 0.875rem;
            color: var(--text-secondary);
            padding: var(--spacing-sm);
            background: var(--bg-hover);
            border-radius: var(--border-radius-sm);
        }

            .schedule-status.active {
                color: var(--success);
                background: rgba(16, 185, 129, 0.1);
                border: 1px solid rgba(16, 185, 129, 0.3);
            }

        .next-restart-time {
            font-weight: 600;
            color: var(--text-primary);
        }

        .instances-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(min(100%, 350px), 1fr));
            gap: var(--spacing-lg);
        }

        .instance-card {
            background: var(--bg-card);
            border-radius: var(--border-radius);
            border: 1px solid var(--border);
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
        }

            .instance-card.online {
                border-color: var(--online);
            }

            .instance-card.offline {
                opacity: 0.7;
                border-color: var(--offline);
            }

            .instance-card:hover {
                transform: translateY(-4px);
                box-shadow: var(--shadow-hover);
            }

            .instance-card.pokebot {
                border-left: 4px solid #10b981;
            }

                .instance-card.pokebot .instance-header {
                    background: linear-gradient(135deg, var(--bg-secondary), rgba(16, 185, 129, 0.1));
                }

            .instance-card.raidbot {
                border: 2px solid #8b5cf6;
            }

                .instance-card.raidbot .instance-header {
                    background: linear-gradient(135deg, var(--bg-secondary), rgba(139, 92, 246, 0.1));
            }

        .instance-header {
            background: var(--bg-secondary);
            padding: var(--spacing-md) var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid var(--border);
            gap: var(--spacing-sm);
        }

        .instance-title {
            font-size: clamp(0.95rem, 3vw, 1.1rem);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            min-width: 0;
            flex: 1;
            flex-direction: column;
            align-items: flex-start;
        }

        .instance-name {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .instance-location {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .remote-indicator {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .master-indicator {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .bot-type-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .bot-type-icon.pokebot {
            color: #10b981;
        }

        .bot-type-icon.raidbot {
            color: #8b5cf6;
        }

        .instance-badge {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            background: var(--bg-hover);
            color: var(--text-secondary);
            white-space: nowrap;
            flex-shrink: 0;
        }

            .instance-badge.pokebot {
                background: rgba(16, 185, 129, 0.2);
                color: #10b981;
                border: 1px solid #10b981;
            }

            .instance-badge.raidbot {
                background: rgba(139, 92, 246, 0.2);
                color: #8b5cf6;
                border: 1px solid #8b5cf6;
        }

        .instance-body {
            padding: var(--spacing-lg);
        }

        .instance-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .info-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-value {
            font-size: 0.95rem;
            font-weight: 600;
            word-break: break-word;
        }

        .bot-status {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-sm);
            background: var(--bg-hover);
            border-radius: var(--border-radius-sm);
        }

        .bot-status-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.875rem;
            padding: var(--spacing-xs) 0;
            gap: var(--spacing-sm);
        }

            .bot-status-item .bot-name {
                display: flex;
                align-items: center;
                gap: var(--spacing-sm);
                min-width: 0;
                flex: 1;
            }

                .bot-status-item .bot-name span:first-child {
                    flex-shrink: 0;
                }

                .bot-status-item .bot-name span:last-child {
                    word-break: break-word;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

            .bot-status-item .bot-state {
                font-weight: 600;
                padding: var(--spacing-xs) var(--spacing-sm);
                border-radius: 4px;
                font-size: 0.75rem;
                white-space: nowrap;
                flex-shrink: 0;
            }

        .bot-state.running {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
        }

        .bot-state.stopped {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
        }

        .bot-state.idle {
            background: rgba(245, 158, 11, 0.2);
            color: var(--idle);
        }

        .bot-state.error {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--danger);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--danger);
            display: flex;
            align-items: flex-start;
            gap: var(--spacing-sm);
            word-break: break-word;
        }

        .toast {
            position: fixed;
            bottom: var(--spacing-xl);
            right: var(--spacing-xl);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md) var(--spacing-lg);
            box-shadow: var(--shadow-hover);
            transform: translateX(calc(100% + var(--spacing-xl)));
            transition: transform 0.3s ease;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            max-width: min(400px, calc(100vw - 2rem));
            word-break: break-word;
            opacity: 1;
        }

            .toast.show {
                transform: translateX(0);
            }

            .toast.success {
                border-color: var(--success);
                background: var(--bg-card);
            }

            .toast.error {
                border-color: var(--danger);
                background: var(--bg-card);
            }

            .toast.warning {
                border-color: var(--warning);
                background: var(--bg-card);
            }

            .toast.info {
                border-color: var(--accent);
                background: var(--bg-card);
            }

        .toast-icon {
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .online-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--online);
            display: inline-block;
            margin-right: var(--spacing-sm);
            flex-shrink: 0;
        }

        .offline-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--offline);
            display: inline-block;
            margin-right: var(--spacing-sm);
            flex-shrink: 0;
        }

        .instance-status-badge {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

            .instance-status-badge.running {
                background: rgba(16, 185, 129, 0.2);
                color: var(--success);
                border: 1px solid var(--success);
            }

            .instance-status-badge.stopped {
                background: rgba(239, 68, 68, 0.2);
                color: var(--danger);
                border: 1px solid var(--danger);
            }

            .instance-status-badge.idle {
                background: rgba(245, 158, 11, 0.2);
                color: var(--idle);
                border: 1px solid var(--idle);
            }

            .instance-status-badge.mixed {
                background: rgba(168, 174, 192, 0.2);
                color: var(--text-secondary);
                border: 1px solid var(--text-secondary);
            }

        .instance-controls {
            position: relative;
        }

        .action-menu-button {
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            color: var(--text-primary);
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            width: 100%;
            justify-content: center;
            min-height: 44px;
        }

            .action-menu-button:hover:not(:disabled) {
                background: var(--accent);
                border-color: var(--accent);
                transform: translateY(-1px);
                box-shadow: var(--shadow);
            }

            .action-menu-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

        .action-menu {
            position: absolute;
            bottom: calc(100% + var(--spacing-xs));
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            box-shadow: var(--shadow-hover);
            overflow: hidden;
            display: none;
            z-index: 1000;
        }

            .action-menu.show {
                display: block;
            }

        .action-menu-item {
            padding: var(--spacing-sm) var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            cursor: pointer;
            transition: background 0.2s ease;
            font-size: 0.875rem;
            white-space: nowrap;
            border: none;
            background: none;
            color: var(--text-primary);
            width: 100%;
            text-align: left;
        }

            .action-menu-item:hover {
                background: var(--bg-hover);
            }

            .action-menu-item.success {
                color: var(--success);
            }

            .action-menu-item.warning {
                color: var(--warning);
            }

            .action-menu-item.danger {
                color: var(--danger);
            }

        .action-menu-divider {
            height: 1px;
            background: var(--border);
            margin: var(--spacing-xs) 0;
        }

        @media (max-width: 1024px) {
            .instances-grid {
                grid-template-columns: repeat(auto-fill, minmax(min(100%, 300px), 1fr));
            }
        }

        @media (max-width: 768px) {
            :root {
                --spacing-lg: 1rem;
                --spacing-xl: 1.5rem;
            }

            .header {
                padding: var(--spacing-md);
            }

            .header-content {
                flex-wrap: wrap;
            }

            .refresh-status {
                order: 3;
                width: 100%;
                justify-content: center;
                margin-top: var(--spacing-sm);
            }

            .main {
                padding: var(--spacing-md);
            }

            .instances-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
            }

            .control-buttons {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: var(--spacing-xs);
            }

            .instance-info {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: var(--spacing-sm);
            }

            .instance-header {
                padding: var(--spacing-md);
                flex-direction: column;
                align-items: flex-start;
                gap: var(--spacing-sm);
            }

            .instance-title {
                width: 100%;
            }

            .bot-status-item {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--spacing-xs);
            }

                .bot-status-item .bot-name {
                    width: 100%;
                }

            .toast {
                bottom: 0;
                right: 0;
                left: 0;
                max-width: none;
                transform: translateY(100%);
                border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0;
                margin: 0;
            }

                .toast.show {
                    transform: translateY(0);
                }

            .action-menu {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                top: auto;
                border-radius: var(--border-radius) var(--border-radius) 0 0;
                max-height: 70vh;
                overflow-y: auto;
            }
        }

        @media (max-width: 480px) {
            .control-buttons {
                grid-template-columns: 1fr 1fr;
            }

            .btn {
                font-size: 0.75rem;
                padding: var(--spacing-sm);
            }

            .global-controls {
                padding: var(--spacing-md);
            }

            .instance-body {
                padding: var(--spacing-md);
            }

            .logo h1 {
                font-size: 1.1rem;
            }
        }

        @media (hover: none) and (pointer: coarse) {
            .btn:hover {
                transform: none;
                box-shadow: none;
            }

            .instance-card:hover {
                transform: none;
                box-shadow: none;
            }

            .action-menu-button:hover {
                transform: none;
            }
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease;
        }

            .modal.show {
                display: flex;
                align-items: center;
                justify-content: center;
                padding: var(--spacing-lg);
            }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: var(--border-radius);
            border: 1px solid var(--border);
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-hover);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .progress-modal-content {
            max-width: 700px;
        }

        .modal-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

            .modal-header h2 {
                margin: 0;
                font-size: 1.5rem;
                color: var(--accent);
            }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

            .modal-close:hover {
                background: var(--bg-hover);
                color: var(--text-primary);
            }

        .modal-body {
            padding: var(--spacing-lg);
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: var(--spacing-lg);
            border-top: 1px solid var(--border);
            display: flex;
            gap: var(--spacing-sm);
            justify-content: flex-end;
        }

        .update-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            padding: var(--spacing-lg);
            background: var(--bg-hover);
            border-radius: var(--border-radius-sm);
            margin-bottom: var(--spacing-lg);
        }

        .version-info {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            align-items: center;
            text-align: center;
        }

        .version-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .version-value {
            font-size: 1.25rem;
            font-weight: 700;
            font-family: monospace;
        }

        .version-new {
            color: var(--success);
        }

        .changelog-section h3 {
            margin: 0 0 var(--spacing-md) 0;
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .changelog-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .progress-step {
            display: flex;
            align-items: flex-start;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .step-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }

        .step-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }

        .step-details {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .progress-bar-container {
            height: 8px;
            background: var(--bg-hover);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: var(--spacing-lg);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-hover) 100%);
            width: 0%;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

            .progress-bar::after {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient( 90deg, transparent 0%, rgba(255, 255, 255, 0.2) 50%, transparent 100% );
                animation: shimmer 2s infinite;
            }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .idle-status {
            background: var(--bg-hover);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .idle-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        .idle-stat {
            text-align: center;
        }

        .idle-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: var(--spacing-xs);
        }

        .idle-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .bot-details {
            margin-top: var(--spacing-md);
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .bot-detail-item {
            padding: var(--spacing-xs);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .update-log {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            font-family: monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .log-entry {
            padding: var(--spacing-xs) 0;
            border-bottom: 1px solid var(--border);
        }

            .log-entry:last-child {
                border-bottom: none;
            }

        .log-time {
            color: var(--text-secondary);
            margin-right: var(--spacing-sm);
        }

        .log-success {
            color: var(--success);
        }

        .log-error {
            color: var(--danger);
        }

        .log-warning {
            color: var(--warning);
        }

        .progress-bar.indeterminate {
            animation: indeterminate 2s linear infinite;
            background: linear-gradient( 90deg, transparent 0%, var(--accent) 50%, transparent 100% );
        }

        @keyframes indeterminate {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .reconnect-status {
            background: var(--bg-hover);
            border: 2px solid var(--warning);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-lg);
            margin-top: var(--spacing-lg);
            text-align: center;
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {
            0%, 100% {
                border-color: var(--warning);
            }

            50% {
                border-color: var(--accent);
            }
        }

        .reconnect-icon {
            font-size: 3rem;
            margin-bottom: var(--spacing-md);
            animation: spin 2s linear infinite;
        }

        .reconnect-text {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
            color: var(--warning);
        }

        .reconnect-hint {
            font-size: 0.875rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            .modal-content {
                max-height: 100vh;
                margin: 0;
                border-radius: 0;
            }

            .update-info {
                grid-template-columns: 1fr;
            }

            .idle-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
            }

            .idle-number {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <h1>Universal Bot Control Center</h1>
                    <div class="status-indicator"></div>
                </div>
                <div class="refresh-status">
                    <span class="refresh-indicator" id="refresh-indicator" title="Auto-refresh active"></span>
                    <button class="btn" onclick="manualRefresh()" title="Refresh now">üîÑ Refresh</button>
                </div>
            </div>
        </header>
        <main class="main">
            <div class="scheduled-restart-section">
                <div class="scheduled-restart-header">
                    <h2>Scheduled Restart</h2>
                </div>
                <div class="restart-schedule-controls">
                    <div class="schedule-toggle">
                        <label class="toggle-switch">
                            <input type="checkbox" id="schedule-restart-toggle" onchange="toggleScheduledRestart()">
                            <span class="toggle-slider"></span>
                        </label>
                        <label for="schedule-restart-toggle">Enable daily restart</label>
                    </div>
                    <div class="time-input-group">
                        <label for="restart-time">Time:</label>
                        <input type="time" id="restart-time" class="time-input" value="00:00" onchange="updateRestartSchedule()">
                    </div>
                    <button class="btn btn-warning" onclick="restartAllInstances()">üîÑ Restart Now</button>
                </div>
                <div id="schedule-status" class="schedule-status" style="display: none;">
                    <span>‚è∞</span>
                    <span>Next restart scheduled for: <span id="next-restart-time" class="next-restart-time">-</span></span>
                </div>
            </div>
            <div class="global-controls">
                <h2>Global Controls - All Instances</h2>
                <div class="control-buttons">
                    <button class="btn btn-success" onclick="sendGlobalCommand('start')">‚ñ∂Ô∏è Start All</button>
                    <button class="btn btn-danger" onclick="sendGlobalCommand('stop')">‚èπÔ∏è Stop All</button>
                    <button class="btn btn-warning" onclick="sendGlobalCommand('idle')">‚è∏Ô∏è Idle All</button>
                    <button class="btn" onclick="sendGlobalCommand('resume')">‚èØÔ∏è Resume All</button>
                    <button class="btn" onclick="sendGlobalCommand('restart')">üîÑ Restart All</button>
                    <button class="btn" onclick="sendGlobalCommand('reboot')">üîå Reboot All</button>
                    <button class="btn" onclick="sendGlobalCommand('screenon')">üí° Screen On</button>
                    <button class="btn" onclick="sendGlobalCommand('screenoff')">üåô Screen Off</button>
                    <button class="btn btn-raidbot" onclick="sendGlobalCommand('refreshmap')" id="refreshMapBtn" style="display: none;">üó∫Ô∏è Refresh Map</button>
                    <button class="btn btn-primary" onclick="updatePokeBotInstances()" id="updatePokeBotBtn">
                        <img src="update_pokebot.png" style="width: 16px; height: 16px; margin-right: 4px;" alt="Update PokeBot"> Update PokeBot
                    </button>
                    <button class="btn btn-primary" onclick="updateRaidBotInstances()" id="updateRaidBotBtn">
                        <img src="update_raidbot.png" style="width: 16px; height: 16px; margin-right: 4px;" alt="Update RaidBot"> Update RaidBot
                    </button>
                </div>
            </div>
            <div id="instances-container" class="instances-grid">
                <div class="loading"><div class="spinner"></div></div>
            </div>
        </main>
    </div>
    <div id="toast" class="toast">
        <span class="toast-icon"></span>
        <div class="toast-content">
            <div class="toast-title"></div>
            <div class="toast-message"></div>
        </div>
    </div>

    <!-- Update Confirmation Modal -->
    <div id="update-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Update Available</h2>
                <button class="modal-close" onclick="closeUpdateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="update-info">
                    <div class="version-info">
                        <span class="version-label">Current Version:</span>
                        <span id="current-version" class="version-value">-</span>
                    </div>
                    <div class="version-info">
                        <span class="version-label">New Version:</span>
                        <span id="new-version" class="version-value version-new">-</span>
                    </div>
                </div>
                <div class="changelog-section">
                    <h3>Changelog</h3>
                    <div id="changelog-content" class="changelog-content">
                        <div class="spinner"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeUpdateModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmUpdate()">
                    <span>‚¨ÜÔ∏è Update All Instances</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Update Progress Modal -->
    <div id="progress-modal" class="modal">
        <div class="modal-content progress-modal-content">
            <div class="modal-header">
                <h2>Update in Progress</h2>
            </div>
            <div class="modal-body">
                <div class="progress-step">
                    <div class="step-icon">‚è≥</div>
                    <div class="step-info">
                        <div id="progress-status" class="step-title">Preparing update...</div>
                        <div id="progress-details" class="step-details"></div>
                    </div>
                </div>

                <div class="progress-bar-container">
                    <div id="progress-bar" class="progress-bar"></div>
                </div>

                <div id="idle-status" class="idle-status" style="display: none;">
                    <div class="idle-grid">
                        <div class="idle-stat">
                            <div class="idle-number" id="bots-idled">0</div>
                            <div class="idle-label">Bots Idled</div>
                        </div>
                        <div class="idle-stat">
                            <div class="idle-number" id="bots-remaining">0</div>
                            <div class="idle-label">Remaining</div>
                        </div>
                        <div class="idle-stat">
                            <div class="idle-number" id="timeout-countdown">300</div>
                            <div class="idle-label">Timeout (s)</div>
                        </div>
                    </div>

                    <div id="bot-details" class="bot-details"></div>
                </div>

                <div id="update-log" class="update-log"></div>
            </div>
            <div class="modal-footer">
                <button id="force-update-btn" class="btn btn-warning" onclick="forceUpdate()" style="display: none;">
                    ‚ö° Force Update Now
                </button>
            </div>
        </div>
    </div>
    <script>
        const API_BASE = '/api/bot';
        let instances = [];
        let refreshInterval;
        let activeToasts = [];

        let isInteracting = false;
        let refreshPaused = false;
        let lastRefreshTime = Date.now();

        document.addEventListener('DOMContentLoaded', () => {
            refreshInstances();
            startAutoRefresh();
            startConnectionMonitor(); // Add this line

            // Helper function for closest() polyfill
            function findClosest(element, selector) {
                if (!element || element.nodeType !== 1) return null;
                
                if (typeof element.closest === 'function') {
                    return element.closest(selector);
                }
                
                // Polyfill for older browsers
                let el = element;
                while (el && el.nodeType === 1) {
                    // Use matches() or fallback to alternative methods
                    let matches = false;
                    if (el.matches) {
                        matches = el.matches(selector);
                    } else if (el.webkitMatchesSelector) {
                        matches = el.webkitMatchesSelector(selector);
                    } else if (el.mozMatchesSelector) {
                        matches = el.mozMatchesSelector(selector);
                    } else if (el.msMatchesSelector) {
                        matches = el.msMatchesSelector(selector);
                    }
                    
                    if (matches) {
                        return el;
                    }
                    el = el.parentElement;
                }
                return null;
            }

            // Close menus when clicking outside
            document.addEventListener('click', (e) => {
                if (e.target && e.target.nodeType === 1) {
                    if (!findClosest(e.target, '.instance-controls')) {
                        document.querySelectorAll('.action-menu.show').forEach(menu => {
                            menu.classList.remove('show');
                        });
                    }
                }
            });

            // Track mouse interaction
            document.addEventListener('mouseenter', (e) => {
                if (e.target && e.target.nodeType === 1) {
                    if (findClosest(e.target, '.instance-card')) {
                        isInteracting = true;
                    }
                }
            }, true);

            document.addEventListener('mouseleave', (e) => {
                if (e.target && e.target.nodeType === 1) {
                    if (findClosest(e.target, '.instance-card')) {
                        isInteracting = false;
                    }
                }
            }, true);

            // Track touch interaction
            document.addEventListener('touchstart', (e) => {
                if (e.target && e.target.nodeType === 1) {
                    if (findClosest(e.target, '.instance-card')) {
                        isInteracting = true;
                    }
                }
            });

            document.addEventListener('touchend', () => {
                setTimeout(() => {
                    isInteracting = false;
                }, 500);
            });
        });

        window.addEventListener('beforeunload', () => {
            if (refreshInterval) clearInterval(refreshInterval);
        });

        let updateState = {
            newVersion: '',
            changelog: '',
            instances: [],
            idleCheckInterval: null,
            countdownInterval: null,
            startTime: null,
            timeout: 300,
            forcedUpdate: false
        };

        // Safe element access helper
        function safeElementAccess(elementId, action) {
            const element = document.getElementById(elementId);
            if (element) {
                action(element);
            } else {
                console.warn(`Element with ID '${elementId}' not found`);
            }
        }

        async function updateAllInstances() {
            // First, check what updates are available
            showModal('update-modal');

            // Reset state
            updateState = {
                newVersion: '',
                changelog: '',
                instances: [],
                idleCheckInterval: null,
                countdownInterval: null,
                startTime: null,
                timeout: 300,
                forcedUpdate: false
            };

            try {
                // Get current instances first to show version info
                const instancesResponse = await fetch(`${API_BASE}/instances`);
                const instancesData = await instancesResponse.json();
                const currentVersion = instancesData.Instances?.[0]?.Version || 'Unknown';

                safeElementAccess('current-version', (el) => {
                    el.textContent = currentVersion;
                });
                safeElementAccess('new-version', (el) => {
                    el.textContent = 'Checking...';
                });
                safeElementAccess('changelog-content', (el) => {
                    el.innerHTML = '<div class="spinner"></div>';
                });

                // Check for updates
                const checkResponse = await fetch(`${API_BASE}/update/check`);
                let updateInfo = { version: 'Unknown', changelog: 'No changelog available' };

                if (checkResponse.ok) {
                    updateInfo = await checkResponse.json();
                    updateState.newVersion = updateInfo.version;
                    updateState.changelog = updateInfo.changelog || 'No changelog available';
                } else {
                    // If check endpoint doesn't exist, proceed with a generic update
                    updateState.newVersion = 'Latest';
                    updateState.changelog = 'Unable to fetch changelog. Update will proceed to latest version.';
                }

                safeElementAccess('new-version', (el) => {
                    el.textContent = updateState.newVersion;
                });
                safeElementAccess('changelog-content', (el) => {
                    el.textContent = updateState.changelog;
                });

            } catch (error) {
                console.error('Error checking updates:', error);
                safeElementAccess('new-version', (el) => {
                    el.textContent = 'Latest';
                });
                safeElementAccess('changelog-content', (el) => {
                    el.textContent = 'Unable to fetch update information. Click Update to proceed.';
                });
            }
        }

        function showModal(modalId) {
            document.getElementById(modalId).classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
            document.body.style.overflow = '';
        }

        function closeUpdateModal() {
            closeModal('update-modal');
        }

        async function confirmUpdate() {
            closeModal('update-modal');
            showModal('progress-modal');

            updateState.startTime = Date.now();
            updateProgress('Initializing update process...', 'Checking all instances for updates', 10);

            try {
                // Start the idle process
                const response = await fetch(`${API_BASE}/update/all`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stage: 'start' })
                });

                if (!response.ok) throw new Error('Update check failed');

                const result = await response.json();

                if (result.UpdatesNeeded === 0) {
                    updateProgress('All instances up to date', 'No updates needed', 100);
                    addLogEntry('All instances are already running the latest version', 'success');
                    setTimeout(() => {
                        closeModal('progress-modal');
                        showToast('info', 'No Updates', 'All instances are already up to date');
                    }, 2000);
                    return;
                }

                // Store instances that need updates
                updateState.instances = result.Results || [];
                const totalInstances = result.TotalInstances || updateState.instances.length;

                updateProgress(
                    'Preparing instances for update',
                    `Found ${result.UpdatesNeeded} instances that need updating`,
                    20
                );
                addLogEntry(`Identified ${result.UpdatesNeeded} instances requiring updates`);
                addLogEntry('Sending idle command to all bots...', 'info');

                // Show idle status immediately
                safeElementAccess('idle-status', (el) => {
                    el.style.display = 'block';
                });
                safeElementAccess('force-update-btn', (el) => {
                    el.style.display = 'inline-flex';
                });

                // Start monitoring idle status
                setTimeout(() => {
                    startIdleMonitoring(totalInstances);
                }, 500);

            } catch (error) {
                console.error('Error updating instances:', error);
                updateProgress('Update failed', error.message, 0);
                addLogEntry(`Update failed: ${error.message}`, 'error');

                setTimeout(() => {
                    closeModal('progress-modal');
                    showToast('error', 'Error', 'Failed to check for updates');
                }, 2000);
            }
        }

        function startIdleMonitoring(totalInstances) {
            let lastIdleCount = 0;
            let lastLogTime = 0;

            updateProgress(
                'Waiting for ALL bots to idle',
                'All bots across all instances must finish their current operations before updating',
                30
            );

            // Update countdown
            updateState.countdownInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - updateState.startTime) / 1000);
                const remaining = Math.max(0, updateState.timeout - elapsed);
                safeElementAccess('timeout-countdown', (el) => {
                    el.textContent = remaining;
                });

                if (remaining === 0 && !updateState.forcedUpdate) {
                    forceUpdate();
                }
            }, 1000);

            // Check idle status using dedicated endpoint
            updateState.idleCheckInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/update/idle-status`);
                    const data = await response.json();

                    const totalBots = data.TotalBots || 0;
                    const idledBots = data.TotalIdleBots || 0;
                    const allIdle = data.AllBotsIdle || false;

                    safeElementAccess('bots-idled', (el) => {
                        el.textContent = idledBots;
                    });
                    safeElementAccess('bots-remaining', (el) => {
                        el.textContent = totalBots - idledBots;
                    });

                    // Build detailed status
                    let detailsHtml = '<div style="margin-top: 10px; font-size: 0.8rem;">';
                    let hasNonIdleBots = false;

                    if (data.Instances) {
                        data.Instances.forEach(instance => {
                            if (instance.NonIdleBots && instance.NonIdleBots.length > 0) {
                                hasNonIdleBots = true;
                                detailsHtml += `<div style="margin-bottom: 5px;">Port ${instance.Port}: `;
                                detailsHtml += instance.NonIdleBots.slice(0, 2).map(b =>
                                    `${b.Name} (${b.Status})`
                                ).join(', ');
                                if (instance.NonIdleBots.length > 2) {
                                    detailsHtml += ` +${instance.NonIdleBots.length - 2} more`;
                                }
                                detailsHtml += '</div>';
                            }
                        });
                    }

                    if (!hasNonIdleBots) {
                        detailsHtml = '<div style="color: var(--success); margin-top: 10px;">‚úÖ All bots across all instances are idle</div>';
                    } else {
                        detailsHtml += '</div>';
                    }

                    safeElementAccess('bot-details', (el) => {
                        el.innerHTML = detailsHtml;
                    });

                    // Log progress when bots idle (but not too frequently)
                    const now = Date.now();
                    if (idledBots > lastIdleCount && now - lastLogTime > 2000) {
                        addLogEntry(`${idledBots}/${totalBots} bots are now idle across all instances`);
                        lastIdleCount = idledBots;
                        lastLogTime = now;

                        // Log which instances still have active bots
                        if (data.Instances) {
                            const activeInstances = data.Instances.filter(i => !i.AllIdle);
                            if (activeInstances.length > 0) {
                                const ports = activeInstances.map(i => i.Port).join(', ');
                                addLogEntry(`Waiting for bots on ports: ${ports}`, 'warning');
                            }
                        }
                    }

                    // Update progress bar
                    const idleProgress = 30 + (idledBots / totalBots) * 40;
                    safeElementAccess('progress-bar', (el) => {
                        el.style.width = `${idleProgress}%`;
                    });

                    // Only proceed if ALL bots are idle
                    if (allIdle && !updateState.forcedUpdate) {
                        clearInterval(updateState.idleCheckInterval);
                        clearInterval(updateState.countdownInterval);
                        addLogEntry('All bots across all instances are now idle!', 'success');
                        proceedWithUpdate();
                    }

                } catch (error) {
                    console.error('Error checking idle status:', error);
                    // Fall back to old method if new endpoint doesn't exist
                    checkIdleStatusFallback();
                }
            }, 2000);
        }

        // Fallback function for older versions
        async function checkIdleStatusFallback() {
            try {
                const response = await fetch(`${API_BASE}/instances`);
                const data = await response.json();

                let totalBots = 0;
                let idledBots = 0;

                data.Instances.forEach(instance => {
                    if (instance.BotStatuses) {
                        instance.BotStatuses.forEach(bot => {
                            totalBots++;
                            const status = bot.Status.toUpperCase();
                            if (status === 'IDLE' || status === 'STOPPED') {
                                idledBots++;
                            }
                        });
                    }
                });

                safeElementAccess('bots-idled', (el) => {
                    el.textContent = idledBots;
                });
                safeElementAccess('bots-remaining', (el) => {
                    el.textContent = totalBots - idledBots;
                });

                if (idledBots === totalBots && !updateState.forcedUpdate) {
                    clearInterval(updateState.idleCheckInterval);
                    clearInterval(updateState.countdownInterval);
                    proceedWithUpdate();
                }
            } catch (error) {
                console.error('Fallback idle check failed:', error);
            }
        }

        async function proceedWithUpdate() {
            updateProgress(
                'Starting updates',
                'All bots are idle. Beginning update process...',
                70
            );
            addLogEntry('All bots successfully idled. Starting updates...', 'success');

            safeElementAccess('idle-status', (el) => {
                el.style.display = 'none';
            });
            safeElementAccess('force-update-btn', (el) => {
                el.style.display = 'none';
            });

            try {
                // Call the update endpoint with proceed stage
                const response = await fetch(`${API_BASE}/update/all`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stage: 'proceed' })
                });

                if (!response.ok) throw new Error('Failed to proceed with updates');

                const result = await response.json();

                // The updates have been triggered, now just show progress
                if (result.UpdatesStarted > 0) {
                    updateProgress(
                        'Updates in progress',
                        `${result.UpdatesStarted} instances are being updated`,
                        90
                    );

                    // Log each update
                    if (result.Results) {
                        result.Results.forEach(r => {
                            if (r.UpdateStarted) {
                                addLogEntry(`Instance on port ${r.Port} update started`, 'success');
                            }
                        });
                    }

                    // Check for master update
                    const masterPort = parseInt(window.location.port || '8080');
                    const masterUpdating = result.Results?.some(r =>
                        r.UpdateStarted && r.Port === masterPort
                    );

                    if (masterUpdating) {
                        masterUpdating = true;
                        setTimeout(() => {
                            updateProgress(
                                'Master instance restarting',
                                'This web interface will temporarily disconnect...',
                                95
                            );
                            addLogEntry('Master instance updating - expect temporary disconnection', 'warning');
                        }, 1000);
                    } else {
                        setTimeout(() => {
                            updateProgress(
                                'Updates complete!',
                                'All instances have been updated successfully',
                                100
                            );
                            addLogEntry('All updates completed successfully!', 'success');

                            setTimeout(() => {
                                closeModal('progress-modal');
                                showToast('success', 'Updates Complete', 'All instances have been updated');
                                refreshInstances(true);
                            }, 2000);
                        }, 3000);
                    }
                }
            } catch (error) {
                console.error('Error proceeding with updates:', error);
                updateProgress('Update failed', error.message, 0);
                addLogEntry(`Failed to proceed with updates: ${error.message}`, 'error');
            }
        }

        function forceUpdate() {
            if (updateState.forcedUpdate) return;

            updateState.forcedUpdate = true;
            clearInterval(updateState.idleCheckInterval);
            clearInterval(updateState.countdownInterval);

            addLogEntry('Timeout reached or forced update triggered', 'warning');
            updateProgress(
                'Forcing update',
                'Proceeding with update despite non-idle bots',
                70
            );

            proceedWithUpdate();
        }

        function updateProgress(status, details, percentage) {
            safeElementAccess('progress-status', (el) => {
                el.textContent = status;
            });
            safeElementAccess('progress-details', (el) => {
                el.textContent = details;
            });
            safeElementAccess('progress-bar', (el) => {
                el.style.width = `${percentage}%`;
            });

            // Update icon based on status
            const iconMap = {
                'Initializing': 'üîç',
                'Preparing': 'üìã',
                'Waiting': '‚è≥',
                'Starting': 'üöÄ',
                'Updating': 'üì¶',
                'Updates complete': '‚úÖ',
                'Update failed': '‚ùå',
                'Forcing': '‚ö°'
            };

            const icon = Object.entries(iconMap).find(([key]) =>
                status.toLowerCase().includes(key.toLowerCase())
            )?.[1] || '‚è≥';

            document.querySelector('.step-icon').textContent = icon;
        }

        function addLogEntry(message, type = 'info') {
            const log = document.getElementById('update-log');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // Connection monitoring
        let connectionLost = false;
        let reconnectInterval = null;
        let masterUpdating = false;

        function startConnectionMonitor() {
            setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/instances`, {
                        method: 'GET',
                        signal: AbortSignal.timeout(2000)
                    });

                    if (!response.ok) throw new Error('Server error');

                    if (connectionLost) {
                        // Connection restored
                        connectionLost = false;
                        handleReconnection();
                    }
                } catch (error) {
                    if (!connectionLost && document.getElementById('progress-modal').classList.contains('show')) {
                        connectionLost = true;
                        handleConnectionLost();
                    }
                }
            }, 1000);
        }

        function handleConnectionLost() {
            if (masterUpdating) return; // Already showing master update UI

            updateProgress(
                'Connection Lost',
                'Connection to server lost. This may be due to the master instance updating...',
                -1 // Special value to indicate unknown progress
            );

            // Change progress bar to indeterminate
            document.getElementById('progress-bar').style.width = '100%';
            document.getElementById('progress-bar').style.opacity = '0.5';
            document.getElementById('progress-bar').classList.add('indeterminate');

            addLogEntry('Lost connection to server - master instance may be updating', 'warning');

            // Show reconnection UI
            showReconnectionUI();
        }

        function showReconnectionUI() {
            const modalBody = document.querySelector('#progress-modal .modal-body');

            // Add reconnection status if not already present
            if (!document.getElementById('reconnect-status')) {
                const reconnectDiv = document.createElement('div');
                reconnectDiv.id = 'reconnect-status';
                reconnectDiv.className = 'reconnect-status';
                reconnectDiv.innerHTML = `
                            <div class="reconnect-icon">üîÑ</div>
                            <div class="reconnect-text">Attempting to reconnect...</div>
                            <div class="reconnect-hint">The master instance is updating. This page will automatically reconnect when the update is complete.</div>
                        `;
                modalBody.appendChild(reconnectDiv);
            }
        }

        function handleReconnection() {
            addLogEntry('Connection restored!', 'success');

            // Remove reconnection UI
            const reconnectStatus = document.getElementById('reconnect-status');
            if (reconnectStatus) {
                reconnectStatus.remove();
            }

            // Reset progress bar
            document.getElementById('progress-bar').classList.remove('indeterminate');
            document.getElementById('progress-bar').style.opacity = '1';

            // Check final update status
            checkFinalUpdateStatus();
        }

        async function checkFinalUpdateStatus() {
            updateProgress(
                'Verifying update status',
                'Checking if all updates completed successfully...',
                90
            );

            try {
                const response = await fetch(`${API_BASE}/instances`);
                const data = await response.json();

                // Check versions
                const versions = data.Instances.map(i => i.Version);
                const allSameVersion = versions.every(v => v === versions[0]);

                if (allSameVersion) {
                    updateProgress(
                        'Updates complete!',
                        `All instances successfully updated to version ${versions[0]}`,
                        100
                    );
                    addLogEntry(`All instances now running version ${versions[0]}`, 'success');

                    setTimeout(() => {
                        closeModal('progress-modal');
                        showToast('success', 'Updates Complete', 'All instances have been updated successfully');
                        refreshInstances(true);
                    }, 3000);
                } else {
                    updateProgress(
                        'Update status unclear',
                        'Some instances may have different versions. Please check manually.',
                        100
                    );
                    addLogEntry('Update completed but version mismatch detected', 'warning');
                }
            } catch (error) {
                updateProgress(
                    'Unable to verify',
                    'Could not verify update status. Please check instances manually.',
                    100
                );
            }
        }

        function startAutoRefresh() {
            refreshInterval = setInterval(() => {
                const hasOpenMenu = document.querySelector('.action-menu.show') !== null;
                const timeSinceLastRefresh = Date.now() - lastRefreshTime;
                const indicator = document.getElementById('refresh-indicator');

                // Update indicator
                if (hasOpenMenu || isInteracting || refreshPaused) {
                    indicator.classList.add('paused');
                    indicator.title = 'Auto-refresh paused';
                } else {
                    indicator.classList.remove('paused');
                    indicator.title = 'Auto-refresh active';
                }

                // Only refresh if no menus are open, not interacting, and not manually paused
                if (!hasOpenMenu && !isInteracting && !refreshPaused && timeSinceLastRefresh >= 5000) {
                    refreshInstances();
                }
            }, 1000); // Check every second but only refresh when conditions are met
        }

        async function refreshInstances(isManual = false) {
            try {
                // Don't refresh if menu is open and it's not a manual refresh
                if (!isManual && document.querySelector('.action-menu.show')) {
                    return;
                }

                lastRefreshTime = Date.now();
                const response = await fetch(`${API_BASE}/instances`);
                if (!response.ok) throw new Error('Failed to fetch instances');

                const data = await response.json();
                instances = data.Instances;

                // Only render if no menus are open or it's a manual refresh
                if (!document.querySelector('.action-menu.show') || isManual) {
                    renderInstances();
                }
            } catch (error) {
                console.error('Error fetching instances:', error);
                showError('Failed to load bot instances. Make sure the bot is running.');
            }
        }

        function renderInstances() {
            const container = document.getElementById('instances-container');

            if (instances.length === 0) {
                container.innerHTML = '<div class="error-message">‚ö†Ô∏è No bot instances found. Make sure at least one PokeBot is running.</div>';
                return;
            }

            // Check if we have any RaidBots to show the refresh map button
            const hasRaidBots = instances.some(instance => instance.BotType === 'RaidBot');
            const refreshMapBtn = document.getElementById('refreshMapBtn');
            if (refreshMapBtn) {
                refreshMapBtn.style.display = hasRaidBots ? 'inline-flex' : 'none';
            }

            // Show/hide update buttons based on available bot types
            const hasPokeBots = instances.some(instance => instance.BotType === 'PokeBot');
            const updatePokeBotBtn = document.getElementById('updatePokeBotBtn');
            const updateRaidBotBtn = document.getElementById('updateRaidBotBtn');
            
            if (updatePokeBotBtn) {
                updatePokeBotBtn.style.display = hasPokeBots ? 'inline-flex' : 'none';
            }
            if (updateRaidBotBtn) {
                updateRaidBotBtn.style.display = hasRaidBots ? 'inline-flex' : 'none';
            }

            container.innerHTML = instances.map(instance => {
                const isOnline = instance.IsOnline || false;
                const statusClass = isOnline ? 'online' : 'offline';
                const botType = instance.BotType || 'Unknown';
                const botTypeClass = botType.toLowerCase();
                const statusIndicator = isOnline ?
                    '<span class="online-indicator"></span>Connected' :
                    '<span class="offline-indicator"></span>Disconnected';

                // Bot type icon and name
                const botIcon = getBotTypeIcon(botType);
                const botTypeName = getBotTypeName(botType);

                let instanceStatus = 'stopped';
                let instanceStatusText = 'Stopped';
                if (instance.BotStatuses && instance.BotStatuses.length > 0) {
                    const runningCount = instance.BotStatuses.filter(b =>
                        b.Status.toUpperCase().includes('RUNNING') ||
                        b.Status.toUpperCase().includes('ACTIVE') ||
                        (!b.Status.toUpperCase().includes('IDLE') &&
                            !b.Status.toUpperCase().includes('STOPPED') &&
                            !b.Status.toUpperCase().includes('ERROR'))
                    ).length;
                    const idleCount = instance.BotStatuses.filter(b =>
                        b.Status.toUpperCase().includes('IDLE')
                    ).length;

                    if (runningCount === instance.BotStatuses.length) {
                        instanceStatus = 'running';
                        instanceStatusText = 'All Running';
                    } else if (idleCount === instance.BotStatuses.length) {
                        instanceStatus = 'idle';
                        instanceStatusText = 'All Idle';
                    } else if (runningCount > 0) {
                        instanceStatus = 'mixed';
                        instanceStatusText = `${runningCount}/${instance.BotStatuses.length} Running`;
                    } else if (idleCount > 0) {
                        instanceStatus = 'idle';
                        instanceStatusText = 'Idle';
                    }
                }

                // Generate location information
                const locationInfo = instance.IP && instance.IP !== '127.0.0.1' ? 
                    `${instance.IP}:${instance.Port}` : 
                    `localhost:${instance.Port}`;
                
                // Generate role indicators
                const roleIndicators = [];
                if (instance.IsMaster) {
                    roleIndicators.push('<span class="master-indicator">Master</span>');
                }
                if (instance.IsRemote) {
                    roleIndicators.push('<span class="remote-indicator">Remote</span>');
                }

                return `
                    <div class="instance-card ${statusClass} ${botTypeClass}" data-port="${instance.Port}" data-ip="${instance.IP || '127.0.0.1'}">
                        <div class="instance-header">
                            <h3 class="instance-title">
                                <div class="instance-name">
                                    <span class="bot-type-icon ${botTypeClass}">${botIcon}</span>
                                    ${instance.Name}
                                    ${roleIndicators.join('')}
                                    <span class="instance-status-badge ${instanceStatus}">${instanceStatusText}</span>
                                </div>
                                <div class="instance-location">${locationInfo}</div>
                            </h3>
                            <span class="instance-badge ${botTypeClass}">${botTypeName}</span>
                        </div>
                        <div class="instance-body">
                            <div class="instance-info">
                                <div class="info-item">
                                    <span class="info-label">Version</span>
                                    <span class="info-value">${instance.Version}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Mode</span>
                                    <span class="info-value">${instance.Mode}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Process ID</span>
                                    <span class="info-value">${instance.ProcessId}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">IP Address</span>
                                    <span class="info-value">${instance.IP || '127.0.0.1'}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Port</span>
                                    <span class="info-value">${instance.Port}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Connection</span>
                                    <span class="info-value">${statusIndicator}</span>
                                </div>
                            </div>

                            ${instance.BotStatuses && instance.BotStatuses.length > 0 ? `
                            <div class="bot-status">
                                <div class="info-label" style="margin-bottom: 0.5rem;">BOTS (${instance.BotStatuses.length})</div>
                                ${instance.BotStatuses.map((bot, index) => `
                                    <div class="bot-status-item">
                                        <span class="bot-name">
                                            <span style="color: ${getStatusColor(bot.Status)};">‚óè</span>
                                            <span>${bot.Name || `Bot ${index + 1}`}</span>
                                        </span>
                                        <span class="bot-state ${getStatusClass(bot.Status)}">${bot.Status}</span>
                                    </div>
                                `).join('')}
                            </div>
                            ` : instance.BotCount > 0 ? `
                            <div class="bot-status">
                                <div class="info-label">BOTS</div>
                                <div class="bot-status-item">
                                    <span class="bot-name">Bot Count: ${instance.BotCount}</span>
                                    <span class="bot-state">Status Unknown</span>
                                </div>
                            </div>
                            ` : ''}

                            <div class="instance-controls">
                                <button class="action-menu-button" onclick="toggleActionMenu(event, '${instance.IP}', ${instance.Port})" ${!isOnline ? 'disabled' : ''}>                                    ‚ö° Actions <span style="font-size: 0.75rem;">‚ñº</span>
                                </button>
                                <div class="action-menu" id="action-menu-${instance.IP.replace(/\./g, '-')}-${instance.Port}">
                                    <button class="action-menu-item success" onclick="sendInstanceCommand('${instance.IP}', ${instance.Port}, 'start')">
                                        ‚ñ∂Ô∏è Start
                                    </button>
                                    <button class="action-menu-item danger" onclick="sendInstanceCommand('${instance.IP}', ${instance.Port}, 'stop')">
                                        ‚èπÔ∏è Stop
                                    </button>
                                    <button class="action-menu-item warning" onclick="sendInstanceCommand('${instance.IP}', ${instance.Port}, 'idle')">
                                        ‚è∏Ô∏è Idle
                                    </button>
                                    <button class="action-menu-item" onclick="sendInstanceCommand('${instance.IP}', ${instance.Port}, 'resume')">
                                        ‚èØÔ∏è Resume
                                    </button>
                                    <div class="action-menu-divider"></div>
                                    <button class="action-menu-item" onclick="sendInstanceCommand('${instance.IP}', ${instance.Port}, 'restart')">
                                        üîÑ Restart
                                    </button>
                                    <button class="action-menu-item danger" onclick="sendInstanceCommand('${instance.IP}', ${instance.Port}, 'reboot')">
                                        üîå Reboot
                                    </button>
                                    <div class="action-menu-divider"></div>
                                    <button class="action-menu-item" onclick="sendInstanceCommand('${instance.IP}', ${instance.Port}, 'screenon')">
                                        üí° Screen On
                                    </button>
                                    <button class="action-menu-item" onclick="sendInstanceCommand('${instance.IP}', ${instance.Port}, 'screenoff')">
                                        üåô Screen Off
                                    </button>
                                    ${botType === 'RaidBot' ? `
                                    <div class="action-menu-divider"></div>
                                    <button class="action-menu-item" onclick="sendInstanceCommand('${instance.IP}', ${instance.Port}, 'refreshmap')" style="color: #8b5cf6;">
                                        üó∫Ô∏è Refresh Map
                                    </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getBotTypeIcon(botType) {
            switch (botType) {
                case 'PokeBot':
                    return 'üéÆ';
                case 'RaidBot':
                    return '‚öîÔ∏è';
                default:
                    return 'ü§ñ';
            }
        }

        function getBotTypeName(botType) {
            switch (botType) {
                case 'PokeBot':
                    return 'PokeBot';
                case 'RaidBot':
                    return 'RaidBot';
                default:
                    return 'Unknown';
            }
        }

        function manualRefresh() {
            // Close all menus
            document.querySelectorAll('.action-menu.show').forEach(menu => {
                menu.classList.remove('show');
            });

            // Force refresh
            refreshInstances(true);
            showToast('info', 'Refreshed', 'Bot instances refreshed');
        }

        function toggleActionMenu(event, ip, port) {            event.stopPropagation();
            const menuId = `action-menu-${ip.replace(/\./g, '-')}-${port}`;
            const menu = document.getElementById(menuId);
            const allMenus = document.querySelectorAll('.action-menu');

            // Close all other menus
            allMenus.forEach(m => {
                if (m.id !== menuId) {
                    m.classList.remove('show');
                }
            });

            // Toggle current menu
            const wasOpen = menu.classList.contains('show');
            menu.classList.toggle('show');

            // Update interaction state
            isInteracting = !wasOpen;

            // If we just closed the last menu, allow refresh again
            if (wasOpen && !document.querySelector('.action-menu.show')) {
                isInteracting = false;
            }
        }

        function getStatusColor(status) {
            const upperStatus = status?.toUpperCase() || '';
            if (upperStatus.includes('RUNNING') || upperStatus.includes('ACTIVE') || upperStatus === 'ONLINE' ||
                (!upperStatus.includes('IDLE') && !upperStatus.includes('STOPPED') && !upperStatus.includes('ERROR') && !upperStatus.includes('UNKNOWN'))) {
                return '#10b981';
            } else if (upperStatus.includes('IDLE') || upperStatus.includes('PAUSED')) {
                return '#f59e0b';
            } else if (upperStatus.includes('STOPPED') || upperStatus.includes('OFFLINE') || upperStatus.includes('DISCONNECTED')) {
                return '#ef4444';
            } else if (upperStatus.includes('ERROR')) {
                return '#ef4444';
            } else {
                return '#6b7280';
            }
        }

        function getStatusClass(status) {
            const upperStatus = status?.toUpperCase() || '';
            if (upperStatus.includes('RUNNING') || upperStatus.includes('ACTIVE') ||
                (!upperStatus.includes('IDLE') && !upperStatus.includes('STOPPED') && !upperStatus.includes('ERROR') && !upperStatus.includes('UNKNOWN'))) {
                return 'running';
            } else if (upperStatus.includes('IDLE')) {
                return 'idle';
            } else if (upperStatus.includes('STOPPED') || upperStatus.includes('ERROR')) {
                return 'stopped';
            } else {
                return 'error';
            }
        }

        async function sendGlobalCommand(command) {
            showToast('info', 'Sending Command', `Sending ${command} to all instances...`);

            try {
                const response = await fetch(`${API_BASE}/command/all`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ Command: command })
                });

                if (!response.ok) throw new Error('Command failed');

                const result = await response.json();
                const successCount = result.SuccessfulCommands || 0;
                const totalCount = result.TotalInstances || 0;

                if (successCount === totalCount && totalCount > 0) {
                    showToast('success', 'Command Sent', `Successfully sent ${command} to all ${totalCount} instances`);
                } else if (successCount > 0) {
                    showToast('warning', 'Partial Success', `Command sent to ${successCount} of ${totalCount} instances`);
                } else {
                    showToast('error', 'Command Failed', `Failed to send command to any instances`);
                }

                setTimeout(() => refreshInstances(true), 1000);
            } catch (error) {
                console.error('Error sending global command:', error);
                showToast('error', 'Error', `Failed to send command: ${command}`);
            }
        }

        async function sendInstanceCommand(ip, port, command) {
            // Close action menu
            const menuId = `action-menu-${ip.replace(/\./g, '-')}-${port}`;
            document.getElementById(menuId).classList.remove('show');
            // Clear interaction state
            isInteracting = false;

            showToast('info', 'Sending Command', `Sending ${command} to instance on ${ip}:${port}...`);

            try {
                const response = await fetch(`${API_BASE}/instances/${ip}:${port}/command`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ Command: command })
                });

                if (!response.ok) throw new Error('Command failed');

                const result = await response.json();
                if (result.Success) {
                    showToast('success', 'Command Sent', `Successfully sent ${command} to instance ${ip}:${port}`);
                } else {
                    showToast('error', 'Command Failed', result.Message || 'Unknown error');
                }

                setTimeout(() => refreshInstances(true), 1000);
            } catch (error) {
                console.error(`Error sending command to ${ip}:${port}:`, error);
                showToast('error', 'Error', `Failed to send command to instance ${ip}:${port}`);
            }
        }

        function showError(message) {
            console.error(message);
            showToast('error', 'Error', message);
        }

        function showToast(type, title, message) {
            const toastId = Date.now();
            const toast = document.getElementById('toast').cloneNode(true);
            toast.id = `toast-${toastId}`;

            const icon = toast.querySelector('.toast-icon');
            const titleEl = toast.querySelector('.toast-title');
            const messageEl = toast.querySelector('.toast-message');

            titleEl.textContent = title;
            messageEl.textContent = message;

            toast.className = 'toast';
            switch (type) {
                case 'success':
                    icon.textContent = '‚úÖ';
                    toast.classList.add('success');
                    break;
                case 'error':
                    icon.textContent = '‚ùå';
                    toast.classList.add('error');
                    break;
                case 'warning':
                    icon.textContent = '‚ö†Ô∏è';
                    toast.classList.add('warning');
                    break;
                case 'info':
                default:
                    icon.textContent = '‚ÑπÔ∏è';
                    toast.classList.add('info');
                    break;
            }

            document.body.appendChild(toast);
            activeToasts.push(toastId);

            // Adjust position for multiple toasts
            const toastHeight = 80; // Approximate height including margin
            const bottomOffset = activeToasts.indexOf(toastId) * toastHeight;

            if (window.innerWidth <= 768) {
                toast.style.bottom = `${bottomOffset}px`;
            } else {
                toast.style.bottom = `${32 + bottomOffset}px`;
            }

            // Force reflow before adding show class
            toast.offsetHeight;

            requestAnimationFrame(() => {
                toast.classList.add('show');
            });

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.remove();
                    activeToasts = activeToasts.filter(id => id !== toastId);

                    // Reposition remaining toasts
                    activeToasts.forEach((id, index) => {
                        const remainingToast = document.getElementById(`toast-${id}`);
                        if (remainingToast) {
                            if (window.innerWidth <= 768) {
                                remainingToast.style.bottom = `${index * toastHeight}px`;
                            } else {
                                remainingToast.style.bottom = `${32 + index * toastHeight}px`;
                            }
                        }
                    });
                }, 300);
            }, 4000);
        }

        // Scheduled Restart Functions
        function toggleScheduledRestart() {
            const toggle = document.getElementById('schedule-restart-toggle');
            const timeInput = document.getElementById('restart-time');
            const statusDiv = document.getElementById('schedule-status');
            
            timeInput.disabled = !toggle.checked;
            
            if (toggle.checked) {
                updateRestartSchedule();
            } else {
                statusDiv.style.display = 'none';
            }
        }

        function updateRestartSchedule() {
            const toggle = document.getElementById('schedule-restart-toggle');
            const timeInput = document.getElementById('restart-time');
            const statusDiv = document.getElementById('schedule-status');
            const nextTimeSpan = document.getElementById('next-restart-time');
            
            if (!toggle.checked) return;
            
            const [hours, minutes] = timeInput.value.split(':');
            const now = new Date();
            const scheduledTime = new Date();
            scheduledTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
            
            // If the time has passed today, schedule for tomorrow
            if (scheduledTime <= now) {
                scheduledTime.setDate(scheduledTime.getDate() + 1);
            }
            
            nextTimeSpan.textContent = scheduledTime.toLocaleString();
            statusDiv.style.display = 'flex';
            statusDiv.classList.add('active');
        }

        function restartAllInstances() {
            if (confirm('Are you sure you want to restart all instances? This will stop all running bots temporarily.')) {
                sendGlobalCommand('restart');
            }
        }

        async function updatePokeBotInstances() {
            await updateSpecificBotType('PokeBot');
        }

        async function updateRaidBotInstances() {
            await updateSpecificBotType('RaidBot');
        }

        async function updateSpecificBotType(botType) {
            showModal('progress-modal');
            document.getElementById('progress-modal-title').textContent = `${botType} Update in Progress`;

            updateState.type = 'update';
            updateState.startTime = Date.now();
            updateProgress(`Initializing ${botType} update process...`, `Starting background ${botType} update process`, 10);

            try {
                const endpoint = botType === 'PokeBot' ? 'pokebot' : 'raidbot';
                const response = await fetch(`${API_BASE}/update/${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!response.ok) throw new Error(`Failed to start ${botType} update`);

                const result = await response.json();

                if (result.Success) {
                    updateProgress(
                        `${botType} update started`,
                        result.Message || `${botType} update process initiated`,
                        50
                    );
                    addLogEntry(`${botType} update process initiated`, 'info');

                    // Show results
                    setTimeout(() => {
                        updateProgress(
                            `${botType} updates initiated`,
                            `${result.UpdatesStarted || 0} ${botType} instances are now updating`,
                            100
                        );

                        setTimeout(() => {
                            closeModal('progress-modal');
                            showToast('success', `${botType} Update Started`, 
                                `Updates initiated for ${result.UpdatesStarted || 0} ${botType} instances`);
                            refreshInstances(true);
                        }, 2000);
                    }, 1000);
                } else {
                    throw new Error(result.Message || `${botType} update failed`);
                }

            } catch (error) {
                console.error(`Error starting ${botType} update:`, error);
                updateProgress(`${botType} update failed`, error.message, 0);
                addLogEntry(`Failed to start ${botType} update: ${error.message}`, 'error');

                setTimeout(() => {
                    closeModal('progress-modal');
                    showToast('error', 'Error', `Failed to start ${botType} update process`);
                }, 2000);
            }
        }
    </script>
</body>
</html>
